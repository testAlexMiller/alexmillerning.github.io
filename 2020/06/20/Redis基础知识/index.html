<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>Redis基础知识 | Alex</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Alex">
    <meta name="author" content="Alex Ning">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/alexmillerning.github.io/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Alex" type="application/atom+xml">
    <link rel="stylesheet" href="/alexmillerning.github.io/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/alexmillerning.github.io/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/alexmillerning.github.io/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/alexmillerning.github.io/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/alexmillerning.github.io/js/html5shiv.min.js"></script>
    <script src="/alexmillerning.github.io/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/alexmillerning.github.io/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/alexmillerning.github.io/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/alexmillerning.github.io/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="https://testalexmiller.github.io/alexmillerning.github.io/2020/06/20/Redis%E5%AE%89%E8%A3%85/" target="_BLANK" class="animsition-link">Redis</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">MySQL</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/alexmillerning.github.io/categories/SpringCloud/Eureka/" class="animsition-link">Eureka<small>(1)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/MySQL/" class="animsition-link">MySQL<small>(14)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/Redis/" class="animsition-link">Redis<small>(3)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/SpringCloud/Ribbon/" class="animsition-link">Ribbon<small>(1)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/SpringBoot/" class="animsition-link">SpringBoot<small>(3)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/SpringCloud/" class="animsition-link">SpringCloud<small>(2)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/MySQL/索引/" class="animsition-link">索引<small>(5)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/MySQL/视图/" class="animsition-link">视图<small>(5)</small></a></li>
				    
				    <li><a href="/alexmillerning.github.io/categories/MySQL/触发器/" class="animsition-link">触发器<small>(4)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="https://testalexmiller.github.io/alexmillerning.github.io/" target="_blank" rel="noopener" class="animsition-link">Alex</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/alexmillerning.github.io/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/alexmillerning.github.io/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/alexmillerning.github.io/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Alex</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2020-06-20T13:40:00.000Z" itemprop="datePublished">
          2020-06-20
      </time>
    
    
    | 
    <a href='/alexmillerning.github.io/tags/Redis/'>Redis</a>
    
    
</span>
                <h1>Redis基础知识</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>欢迎来到我的私人<a href="https://testalexmiller.github.io/alexmillerning.github.io/" target="_blank" rel="noopener">笔记</a>!该笔记摘录网上资源并加入个人总结,相关内容仅仅用于个人记录和学习,特此申明!!!<br>该章节内容包括:</p>
<ul>
<li>Redis内存统计</li>
<li>Redis内存划分</li>
<li>Redis数据存储的细节</li>
<li>Redis的对象类型与内部编码</li>
<li>实用方法</li>
</ul>
<h1 id="一-Redis内存统计"><a href="#一-Redis内存统计" class="headerlink" title="一. Redis内存统计"></a>一. Redis内存统计</h1><h2 id="1-通过客户端连接Redis服务器-使用命令查看"><a href="#1-通过客户端连接Redis服务器-使用命令查看" class="headerlink" title="1. 通过客户端连接Redis服务器,使用命令查看"></a>1. 通过客户端连接Redis服务器,使用命令查看</h2><h3 id="1-登录"><a href="#1-登录" class="headerlink" title="(1) 登录"></a>(1) 登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入密码登录</span></span><br><span class="line">[redis@bogon logs]$ /usr/<span class="built_in">local</span>/bin/redis-cli -a 123456</span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#先登录,再输入密码</span></span><br><span class="line">[redis@bogon logs]$ /usr/<span class="built_in">local</span>/bin/redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用命令查看内存使用情况"><a href="#2-使用命令查看内存使用情况" class="headerlink" title="(2) 使用命令查看内存使用情况"></a>(2) 使用命令查看内存使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:586584</span><br><span class="line">used_memory_human:572.84K</span><br><span class="line">used_memory_rss:2600960</span><br><span class="line">used_memory_rss_human:2.48M</span><br><span class="line">used_memory_peak:586584</span><br><span class="line">used_memory_peak_human:572.84K</span><br><span class="line">used_memory_peak_perc:100.00%</span><br><span class="line">used_memory_overhead:541578</span><br><span class="line">used_memory_startup:524520</span><br><span class="line">used_memory_dataset:45006</span><br><span class="line">used_memory_dataset_perc:72.52%</span><br><span class="line">allocator_allocated:632136</span><br><span class="line">allocator_active:913408</span><br><span class="line">allocator_resident:3145728</span><br><span class="line">total_system_memory:1023688704</span><br><span class="line">total_system_memory_human:976.27M</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.44</span><br><span class="line">allocator_frag_bytes:281272</span><br><span class="line">allocator_rss_ratio:3.44</span><br><span class="line">allocator_rss_bytes:2232320</span><br><span class="line">rss_overhead_ratio:0.83</span><br><span class="line">rss_overhead_bytes:-544768</span><br><span class="line">mem_fragmentation_ratio:4.77</span><br><span class="line">mem_fragmentation_bytes:2055392</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:16986</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>used_memory:Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。(从Redis角度得到的量)</li>
<li>used_memory_rss:Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。(从操作系统角度得到的量)</li>
<li>mem_fragmentation_ratio:内存碎片比率，该值是used_memory_rss / used_memory的比值。</li>
</ul>
<p><strong>mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。</strong><br><strong>mem_fragmentation_ratio&lt;1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。</strong><br><strong>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；上面截图中的mem_fragmentation_ratio值很大，是因为还没有向Redis中存入数据，Redis进程本身运行的内存使得used_memory_rss 比used_memory大得多。</strong></p>
<ul>
<li>mem_allocator:Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。</li>
</ul>
<h1 id="二-Redis内存划分"><a href="#二-Redis内存划分" class="headerlink" title="二. Redis内存划分"></a>二. Redis内存划分</h1><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h2><p>这部分内存会统计在used_memory中</p>
<h2 id="2-进程本身云运行需要的内存"><a href="#2-进程本身云运行需要的内存" class="headerlink" title="2. 进程本身云运行需要的内存"></a>2. 进程本身云运行需要的内存</h2><p>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。(除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。)</p>
<h2 id="3-缓冲内存"><a href="#3-缓冲内存" class="headerlink" title="3. 缓冲内存"></a>3. 缓冲内存</h2><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p>
<h2 id="4-内存碎片"><a href="#4-内存碎片" class="headerlink" title="4. 内存碎片"></a>4. 内存碎片</h2><p>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。(如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。)</p>
<h1 id="三-Redis数据存储的细节"><a href="#三-Redis数据存储的细节" class="headerlink" title="三. Redis数据存储的细节"></a>三. Redis数据存储的细节</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">class dictEntry&#123;</span><br><span class="line">    void key*</span><br><span class="line">    void val*</span><br><span class="line">    struct dictEntry* next</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class sds&#123;</span><br><span class="line">    &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">class redisObject&#123;</span><br><span class="line">    unsigned type</span><br><span class="line">    unsigned encoding</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS</span><br><span class="line">    int refcount</span><br><span class="line">    void *ptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class sdS&#123;</span><br><span class="line">    &quot;world&quot;</span><br><span class="line">&#125;</span><br><span class="line">    dictEntry --&gt; sds</span><br><span class="line">    dictEntry --&gt;  redisObject</span><br><span class="line">    redisObject --&gt; sdS</span><br></pre></td></tr></table></figure>

<ul>
<li>dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。<strong>(有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。)</strong></li>
<li>Key：Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。</li>
<li>reidsObject: Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。</li>
</ul>
<h2 id="2-jemalloc"><a href="#2-jemalloc" class="headerlink" title="2. jemalloc"></a>2. jemalloc</h2><p>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。</p>
<p>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
<ul>
<li>jemalloc划分的内存单元</li>
</ul>
<table>
<thead>
<tr>
<th>种类</th>
<th>空间/byte</th>
<th>大小/bit</th>
</tr>
</thead>
<tbody><tr>
<td>Small</td>
<td>8</td>
<td>[8]</td>
</tr>
<tr>
<td></td>
<td>16</td>
<td>[16,32,48,…,128]</td>
</tr>
<tr>
<td></td>
<td>32</td>
<td>[160,192,224,256]</td>
</tr>
<tr>
<td></td>
<td>64</td>
<td>[320,384,448,512]</td>
</tr>
<tr>
<td></td>
<td>128</td>
<td>[640,768,896,1024]</td>
</tr>
<tr>
<td></td>
<td>256</td>
<td>[1280,1536,1792,2048]</td>
</tr>
<tr>
<td></td>
<td>512</td>
<td>[2560,3072,3584]</td>
</tr>
<tr>
<td>Large</td>
<td>4kiB</td>
<td>[4kiB,8kiB,12kiB,…,4072kiB]</td>
</tr>
<tr>
<td>Huge</td>
<td>4MiB</td>
<td>[4MiB,8MiB,12MiB,…]</td>
</tr>
</tbody></table>
<h2 id="3-redisObject"><a href="#3-redisObject" class="headerlink" title="3. redisObject"></a>3. redisObject</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">　　<span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">　　<span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">　　<span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">　　<span class="keyword">int</span> refcount;</span><br><span class="line">　　<span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<ul>
<li>type: type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用type命令获取指定对象的类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> mykey</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>encoding: encoding表示对象的内部编码，占4个比特。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用object encoding命令查看对象的编码方式</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding mykey</span><br><span class="line"><span class="string">"int"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>lru: lru记录的是对象最后一次被命令程序访问的时间(通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。)(24bit)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding mykey</span><br><span class="line"><span class="string">"int"</span></span><br><span class="line">127.0.0.1:6379&gt; object idletime mykey</span><br><span class="line">(<span class="built_in">integer</span>) 18759</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">"123456"</span></span><br><span class="line">127.0.0.1:6379&gt; object idletime mykey</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><em>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。</em></p>
<ul>
<li><p>refcount: refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。Redis中被多次使用的对象(refcount&gt;1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。(32bit)</p>
</li>
<li><p>ptr: ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。(64bit)</p>
</li>
</ul>
<h2 id="4-SDS"><a href="#4-SDS" class="headerlink" title="4.SDS"></a>4.SDS</h2><h3 id="1-SDS结构"><a href="#1-SDS结构" class="headerlink" title="(1) SDS结构"></a>(1) SDS结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">//buf已使用的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//buf未使用的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/06/12/vOcPH8MoeIFD65f.png" alt="image.png"></p>
<h3 id="2-SDS结构占据空间"><a href="#2-SDS结构占据空间" class="headerlink" title="(2) SDS结构占据空间"></a>(2) SDS结构占据空间</h3><ul>
<li>buf[]占据空间=len+free+结尾空字符=len+free+1  </li>
<li>len占据空间=4  </li>
<li>free占据空间=4</li>
<li>SDS占据空间=buf[]占据空间+len占据空间+free占据空间=len+free+1+4+4=len+free+9</li>
</ul>
<h3 id="3-SDS与C字符串的应用"><a href="#3-SDS与C字符串的应用" class="headerlink" title="(3) SDS与C字符串的应用"></a>(3) SDS与C字符串的应用</h3><p>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。</p>
<p><strong>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串</strong></p>
<h1 id="四-Redis的对象类型与内部编码"><a href="#四-Redis的对象类型与内部编码" class="headerlink" title="四. Redis的对象类型与内部编码"></a>四. Redis的对象类型与内部编码</h1><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h2><h3 id="1-概况"><a href="#1-概况" class="headerlink" title="(1) 概况"></a>(1) 概况</h3><p>字符串长度不能超过512MB</p>
<h3 id="2-内部编码"><a href="#2-内部编码" class="headerlink" title="(2) 内部编码"></a>(2) 内部编码</h3><ul>
<li>int：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。</li>
<li>embstr：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</li>
<li>raw：大于39个字节的字符串</li>
</ul>
<h3 id="3-编码转换"><a href="#3-编码转换" class="headerlink" title="(3) 编码转换"></a>(3) 编码转换</h3><p>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</p>
<p>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> encodekey hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding encodekey</span><br><span class="line"><span class="string">"embstr"</span></span><br><span class="line">127.0.0.1:6379&gt; append encodekey ,world</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; get encodekey</span><br><span class="line"><span class="string">"hello,world"</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding encodekey</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h2><h3 id="1-概况-1"><a href="#1-概况-1" class="headerlink" title="(1) 概况"></a>(1) 概况</h3><p>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。</p>
<h3 id="2-内部编码-1"><a href="#2-内部编码-1" class="headerlink" title="(2) 内部编码"></a>(2) 内部编码</h3><ul>
<li>双端链表: 由一个list结构和多个listNode结构组成</li>
</ul>
<p><img src="https://i.loli.net/2020/06/12/po9YfkL825TGbZ3.png" alt="image.png"></p>
<ul>
<li>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</li>
</ul>
<h3 id="3-编码转换-1"><a href="#3-编码转换-1" class="headerlink" title="(3) 编码转换"></a>(3) 编码转换</h3><p>只有同时满足下面两个条件时，才会使用压缩列表(编码只可能由压缩列表转化为双端链表，反方向则不可能)</p>
<ul>
<li>列表中元素数量小于512个</li>
<li>列表中所有字符串对象都不足64字节</li>
</ul>
<h2 id="3-哈希"><a href="#3-哈希" class="headerlink" title="3. 哈希"></a>3. 哈希</h2><h3 id="1-概况-2"><a href="#1-概况-2" class="headerlink" title="(1) 概况"></a>(1) 概况</h3><p>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。</p>
<h3 id="2-内部编码-2"><a href="#2-内部编码-2" class="headerlink" title="(2) 内部编码"></a>(2) 内部编码</h3><ul>
<li>压缩列表</li>
<li>哈希表</li>
</ul>
<p><img src="https://i.loli.net/2020/06/12/wWYLFpeRbNndXrV.png" alt="image.png"></p>
<ul>
<li>dictEntry</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键值对中的键(8bit)</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型(8bit)</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下一个dictEntry，用于解决哈希冲突问题(8bit)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<ul>
<li>bucket</li>
</ul>
<p>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。</p>
<ul>
<li>dictht</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//table属性是一个指针，指向bucket</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//属性记录了哈希表的大小，即bucket的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//used记录了已使用的dictEntry的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<ul>
<li>dict</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>只有同时满足下面两个条件时，才会使用压缩列表</p>
<ul>
<li>哈希中元素数量小于512个</li>
<li>哈希中所有键值对的键和值字符串长度都小于64字节-</li>
</ul>
<p><strong>如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建hash k1,v1 k2,v2 k3,v3</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash k1 v1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash k2 v2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash k3 v3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#此时hash的类型为压缩列表</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding myhash</span><br><span class="line"><span class="string">"ziplist"</span></span><br><span class="line"><span class="comment">#向hash中添加长度超过64bit的字符串</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash k4 v44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#此时hash的类型为hashtable</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding myhash</span><br><span class="line"><span class="string">"hashtable"</span></span><br><span class="line"><span class="comment">#删除长度超过64bit的键值对,hash的类型依旧为hashtable</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash k4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding myhash</span><br><span class="line"><span class="string">"hashtable"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-集合"><a href="#4-集合" class="headerlink" title="4. 集合"></a>4. 集合</h2><h3 id="1-概况-3"><a href="#1-概况-3" class="headerlink" title="(1) 概况"></a>(1) 概况</h3><p>集合与列表有两点不同：</p>
<ul>
<li>集合中的元素是无序的，因此不能通过索引来操作元素</li>
<li>集合中的元素不能有重复</li>
</ul>
<h3 id="2-内部编码-3"><a href="#2-内部编码-3" class="headerlink" title="(2) 内部编码"></a>(2) 内部编码</h3><ul>
<li>整数集合（intset）</li>
<li>哈希表（hashtable）。</li>
</ul>
<p><strong>注意: 集合在使用哈希表时，值全部被置为null</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><em>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于集合数量较少，因此操作的时间并没有明显劣势。</em></p>
<h3 id="3-编码转换-2"><a href="#3-编码转换-2" class="headerlink" title="(3) 编码转换"></a>(3) 编码转换</h3><p>只有同时满足下面两个条件时，集合才会使用整数集合</p>
<ul>
<li>集合中元素数量小于512个</li>
<li>集合中所有元素都是整数值</li>
</ul>
<p><strong>如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建set 1,2,3</span></span><br><span class="line">127.0.0.1:6379&gt; 127.0.0.1:6379&gt; sadd myset 1 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">#此时set的类型为intset</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line"><span class="string">"intset"</span></span><br><span class="line"><span class="comment">#往set中添加hello字符串</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#此时set的类型变为hashtable</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line"><span class="string">"hashtable"</span></span><br><span class="line"><span class="comment">#即使删除hello字符,set的类型依旧是hashtable</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure>

<h2 id="5-有序集合"><a href="#5-有序集合" class="headerlink" title="5. 有序集合"></a>5. 有序集合</h2><h3 id="1-概况-4"><a href="#1-概况-4" class="headerlink" title="(1) 概况"></a>(1) 概况</h3><p>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p>
<h3 id="2-内部编码-4"><a href="#2-内部编码-4" class="headerlink" title="(2) 内部编码"></a>(2) 内部编码</h3><ul>
<li>压缩列表（ziplist）</li>
<li>跳跃表（skiplist）<br>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。</li>
</ul>
<h3 id="3-编码转换-3"><a href="#3-编码转换-3" class="headerlink" title="(3) 编码转换"></a>(3) 编码转换</h3><p>只有同时满足下面两个条件时，才会使用压缩列表：</p>
<ul>
<li>有序集合中元素数量小于128个</li>
<li>有序集合中所有成员长度都不足64字节。</li>
</ul>
<p><strong>如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建ziplist A B C D</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 1 A 2 B 3 C</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">#此时类型为ziplist</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding myzset</span><br><span class="line"><span class="string">"ziplist"</span></span><br><span class="line"><span class="comment">#添加长度大于64bit的元素</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 4 DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#此时类型为skiplist</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding myzset</span><br><span class="line"><span class="string">"skiplist"</span></span><br><span class="line"><span class="comment">#即使删除长度大于64bit的元素,类型依旧是skiplist</span></span><br><span class="line">127.0.0.1:6379&gt; zrem myzset DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding myzset</span><br><span class="line"><span class="string">"skiplist"</span></span><br></pre></td></tr></table></figure>

<h1 id="五-实用方法"><a href="#五-实用方法" class="headerlink" title="五. 实用方法"></a>五. 实用方法</h1><h2 id="1-估算Redis内存使用量"><a href="#1-估算Redis内存使用量" class="headerlink" title="1. 估算Redis内存使用量"></a>1. 估算Redis内存使用量</h2><p>假设有90000个键值对(使用hashtable存储)，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。</p>
<h3 id="1-判断字符串类型"><a href="#1-判断字符串类型" class="headerlink" title="(1) 判断字符串类型"></a>(1) 判断字符串类型</h3><ul>
<li>int：8Byte的长整型</li>
<li>embstr：&lt;=39Byte的字符串</li>
<li>raw：大于39Byte的字符串</li>
</ul>
<h3 id="1-计算dictEntry指针大小"><a href="#1-计算dictEntry指针大小" class="headerlink" title="(1) 计算dictEntry指针大小"></a>(1) 计算dictEntry指针大小</h3><p>dictEntry有3个指针组成，在64位机器下占24个Byte，jemalloc会为它分配<strong>32Byte</strong>大小的内存单元</p>
<h3 id="2-计算dictEntry指向的key大小"><a href="#2-计算dictEntry指向的key大小" class="headerlink" title="(2) 计算dictEntry指向的key大小"></a>(2) 计算dictEntry指向的key大小</h3><p>key使用SDS结构存储字符串<br>SDS占据空间=buf[]占据空间+len占据空间+free占据空间=len+free+1+4+4=len+free+9=7+9=16bit<br>jemalloc会为它分配<strong>16Byte</strong>大小的内存单元</p>
<h3 id="3-计算dictEntry指向的RedisObject大小"><a href="#3-计算dictEntry指向的RedisObject大小" class="headerlink" title="(3) 计算dictEntry指向的RedisObject大小"></a>(3) 计算dictEntry指向的RedisObject大小</h3><p>RedisObject占据空间=type占据空间+encoding占据空间+lru占据空间+refcount占据空间+ptr占据空间=4+4+24+32+64=128bit<br>jemalloc会为它分配<strong>16Byte</strong>大小的内存单元</p>
<h3 id="4-计算dictEntry指向的value大小"><a href="#4-计算dictEntry指向的value大小" class="headerlink" title="(4) 计算dictEntry指向的value大小"></a>(4) 计算dictEntry指向的value大小</h3><p>value使用SDS结构存储字符串<br>SDS占据空间=buf[]占据空间+len占据空间+free占据空间=len+free+1+4+4=len+free+9=7+9=16bit<br>jemalloc会为它分配<strong>16Byte</strong>大小的内存单元</p>
<h3 id="5-计算dictEntry总大小"><a href="#5-计算dictEntry总大小" class="headerlink" title="(5) 计算dictEntry总大小"></a>(5) 计算dictEntry总大小</h3><p>dictEntry=dictEntry指针大小+dictEntry指向的key大小+dictEntry指向的RedisObject大小+dictEntry指向的value大小=32Byte+16Byte+16Byte+16Byte=<strong>80Byte</strong></p>
<h3 id="6-计算buket大小"><a href="#6-计算buket大小" class="headerlink" title="(6) 计算buket大小"></a>(6) 计算buket大小</h3><p>bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。</p>
<h3 id="7-求和"><a href="#7-求和" class="headerlink" title="(7) 求和"></a>(7) 求和</h3><p>90000个键值对占据内存大小=90000*80Byte+131072*80Byte=8248576Byte=8055.25KB=7.8665MB</p>
<p><strong>备注:</strong><br><em>1 byte = 8 bit</em><br><em>1 KB = 1024 bytes</em><br><em>1 MB = 1024 KB</em><br><em>1 GB = 1024 MB</em></p>
<h2 id="2-优化内存占用"><a href="#2-优化内存占用" class="headerlink" title="2. 优化内存占用"></a>2. 优化内存占用</h2><h3 id="1-利用jemalloc特性进行优化"><a href="#1-利用jemalloc特性进行优化" class="headerlink" title="(1) 利用jemalloc特性进行优化"></a>(1) 利用jemalloc特性进行优化</h3><p>由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。</p>
<p>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p>
<h3 id="2-使用整型-长整型"><a href="#2-使用整型-长整型" class="headerlink" title="(2) 使用整型/长整型"></a>(2) 使用整型/长整型</h3><p>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。</p>
<h3 id="3-共享对象"><a href="#3-共享对象" class="headerlink" title="(3) 共享对象"></a>(3) 共享对象</h3><p>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。</p>
<p><em>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。</em></p>
<h3 id="4-避免过度设计"><a href="#4-避免过度设计" class="headerlink" title="(4) 避免过度设计"></a>(4) 避免过度设计</h3><p>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。</p>
<p>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。</p>
<h2 id="3-关注内存碎片率"><a href="#3-关注内存碎片率" class="headerlink" title="3. 关注内存碎片率"></a>3. 关注内存碎片率</h2><p>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。</p>
<ul>
<li><p>如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p>
</li>
<li><p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p>
</li>
<li><p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p>
</li>
</ul>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/alexmillerning.github.io/2020/06/20/Redis%E5%AE%89%E8%A3%85/" style="float: left;">
        ← Redis安装
    </a>
    
    
    <a class="pull-right" href="/alexmillerning.github.io/2020/06/20/Redis%E6%8C%81%E4%B9%85%E5%8C%96/">
        Redis持久化 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Alex Ning. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" target="_blank" rel="noopener" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/alexmillerning.github.io/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/alexmillerning.github.io/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/alexmillerning.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/alexmillerning.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
